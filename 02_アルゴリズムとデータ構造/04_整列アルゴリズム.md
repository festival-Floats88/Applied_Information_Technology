# **4. 整列アルゴリズム**

## **1. 選択法**

**選択法**は未整列領域の最小値または最大値を選び, 整列済み領域に追加することで, 配列を徐々に整列状態に近づける.

## **2. バブルソート**

**バブルソート**は, 整列対象の`隣接要素を比較し, 逆順であれば交換`することを繰り返す.

隣接要素の比較・交換を未整列要素から末尾に向けて行うことで, 最後尾の要素が整列済み領域に加わる. これを, 全要素が整列済みになるまで繰り返す.

## **3. 挿入法**

**挿入法**は, 未整列領域から要素を1つ取り出し, 取り出した要素を`整列済みの連の適切な位置に挿入`する. これを繰り返すことで, 整列済みの連が徐々に大きくなる.

## **4. シェルソート**

**シェルソート**は挿入法の改良である.

挿入法には, 配列済みに近い状態であれば, 効率が良くないという特徴がある. そこで, シェルソートは配列から一定間隔h毎に要素を抜き取り, 抜き取った要素間で挿入法を行う.

同様の整列処理を, `間隔hを徐々に小さくしながら繰り返す`. 最終的に間隔をh = 1にすれば, 挿入法と同じ処理を行うものの, 効率よく整列を行うことが可能である.

## **5. クイックソート**

**クイックソート**は, 整列対象となる配列を分割する操作繰り返して整列を行う.

まず基準値を選択し, 配列を基準値よりも小さな要素の部分列Lと基準値よりも大きな要素の部分列Rに分割する. 部分列RとLに対して, 同様の分割処理を繰り返せば, 最終的に配列全体を整列できる.

通常, `クイックソートは配列の分割処理を再帰的に繰り返す`.

## **6. ヒープソート**

**ヒープ**は最大値(または最小値)を効率よく取り出すことのできるデータ構造で, **ヒープソート**はこの性質を利用する.

まず, 配列の未整列領域からヒープを作成する. 次に, ヒープから最大値を取り出し, 確定領域に加える. 最大値を取り出した後のヒープは再構成し, 次の取り出しに備える.

## **7. マージソート**

**マージソート**は, `整列した2つの配列を整列順を保って併合`することで, 整列を行う.

マージソートはクイックソートとよく似ているが, クイックソートが分割時に整列を行うのに対し, マージソートは分割した列を併合しながら整列させていく.

## **8. 整列アルゴリズムの計算量**

各種整列アルゴリズムの計算量をまとめる. なお**安定**とは, 同じキー値をもつデータの順序関係が, 整列後も保たれていることで, xがついたアルゴリズムにはこの保証がない.

| 整列法 | 計算量 | 安定 |
| :-- | :-: | :-: |
| 選択法 | $O(N^2)$ | x |
| バブルソート | $O(N^2)$ | o |
| 挿入法 | $O(N^2)$ | o |
| シェルソート | $O(N^{1.2})$~$O(N^{1.5})$ | x |
| クイックソート | $O(N\log{N})$ | x |
| ヒープソート | $O(N\log{N})$ | x |
| マージソート | $O(N\log{N})$ | o |
