# **3. 探索アルゴリズム**

## **1. 線形探索**

**線形探索**は, 配列の先頭の要素から順に1要素ずつ, 目的の要素を探していく**探索アルゴリズム**である. データ構造を選ばない, 汎用性の高いアルゴリズムである.

### **線形探索のプログラム**

配列DATAからkeyと同じ値を持つ要素を線形探索する. 探索に成功した場合は1を, 失敗した場合は0を返却する.

DATAは要素数がNで予め宣言され, keyは引数で受け取るものとする.

```python
def linearSearch(key):
    i = 0
    while (i < N) and (DATA[i] != key):
        i = i + 1
    if i == N:
        return 0
    else:
        return 1
```

### **線形探索の評価**

線形探索のループの回数は,最小で1, 最大でNである. 探索データが必ず配列に含まれているとしたとき,平均で$\displaystyle \frac{N + 1}{2}$となる.

このようなアルゴリズムの処理時間は, `データ数Nに比例`するので, *O*(N)と評価できる.

## **2. 2分探索**

**2分探索**は, 要素がキー値の昇順または降順に並んでいる配列において, `探索範囲を2分しながら指定されたキー値を持つ要素を探し出す`アルゴリズムである.

中央値とキー値を大小を比較し, 格納されていると思われる方を採用する. その採用された配列(2分された一方)を更に2分して新たにできた中央値とキー値の大小を比較し, 格納されていると思われる方を採用する. この操作を繰り返してデータの中央値とキー値が一致すれば探索成功となる.

### **2分探索のプログラム**

昇順に整列された配列DATAからkeyと同じ値を持つ要素を2分探索する. 探索に成功した場合は1を, 失敗した場合は0を返却する.

DATAはN個の要素を持つグローバル変数として定義され, keyは引数で受け取る.

> **グローバル変数**: 複数の関数から使用できる変数
>> **ローカル変数**: 1つの関数内でのみ使用できる変数

```python
low = 0
high = N - 1
middle = (low + high) // 2

def binarySearch(key):
    while (low <= high) and (DATA[middle] != key):
        if DATA[middle] > key:
            high = middle - 1
        else:
            low = middle + 1
        middle = (low + high) // 2

    if low <= high:
        return 1
    else:
        return 0
```

### **2分探索の評価**

最小比較回数は1, 最大比較回数は$\displaystyle \log_{2}{N} + 1$, 平均比較回数は$\displaystyle \log_{2}{N}$となる.

計算量は*O*($\displaystyle \log_{2}{N}$)と評価される.

## **3. ハッシュ探索**

**ハッシュ探索**はハッシュ表を利用した探索である.

### **ハッシュ表**

**ハッシュ表**は, データの格納位置を「キーのハッシュ値」とするデータ構造である. 実現には配列が用いられることが多く, ハッシュ値を配列の添え字に関連づけて格納する.

> **ハッシュ値**: 元になるデータから一定の計算手順により求められた, 規則性のない固定長の値

### **衝突**(collision)

キー値が異なるにも関わらず, 既存のデータと同じハッシュ値が計算されてしまうことがある. これを**衝突**という. このとき, 衝突を起こしたデータを**シノニム**という.

シノニムは, 次のいずれかの方法を用いて格納する.

| 名称 | 説明 |
| -: | :- |
| オープンアドレス法 | 新たな格納位置を計算する |
| チェーン法 | 本来の格納位置を先頭とする`リスト構造に追加`する |

オープンアドレス法において, 再ハッシュの値に「前回のハッシュ値 + 1」を用いることがある. このとき, シノニムは本来の格納位置に後続する最初の空き容量に格納される. 末尾まで空きがなければ先頭に戻って探すようにすれば, ハッシュ表が満杯でない限りどこかに格納される.

### **ハッシュ探索のプログラム**

シノニムをオープンアドレス法で記録するハッシュ表HASHを探索する.

探索に成功した場合はデータ領域の値を, 失敗した場合はNULLを返却する. なお, ハッシュ関数hashはプログラムは省略する. またハッシュ表には少なくとも1つの空き領域があるものとする.

```python
def openAddress(key):
    h = hash(key)

    while (HASH[h] != {}) and (key not in HASH[h].keys()):
        h = reHash(h)
    if key in HASH[h].keys():
        return HASH[h].values()
    else:
        return None

def reHush(key):
    if key != N:
        return key + 1
    else:
        return 0
```

探索対象が衝突を起こしていた場合は, hashで求めた位置hには格納されていない. そこで, whileループに入り, hを再ハッシュで更新しながら探索を続けている.

### **ハッシュ探索の評価**

ハッシュ探索の効率はシノニムの有無により変わる. ハッシュのサイズに余裕があり, ハッシュ関数が偏りなくハッシュ値を生成するとき, 衝突は稀にしか起こらない. このとき, `ハッシュ探索の計算量は`*`O`*`(1)`である.
