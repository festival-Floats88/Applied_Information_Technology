# **1. データ構造**

## **1. リスト構造**

**リスト構造**は要素をチェーンのようにつなぐデータ構造である. 要素はデータを格納する**データ部**と, 次につながる要素(次要素)の位置情報を持つ**ポインタ部**から構成される.

`要素の位置は1つ前の要素が保持`しているが, リストの開始位置を指すポインタを別途で用意しなければならない. ポインタの内容は, 次要素が格納されたメモリのアドレスなどである. 最終要素のポインタは**NULL**である.

### **要素の追加・削除**

リスト構造への要素の追加/削除は, それを行う前後の要素を修正するだけで簡単に実現できる. これは, 挿入場所を確保しなければならない"配列"に比べて, 非常に優れた性質である.

リストへの挿入は, 次の手順で行われる.

1. 挿入位置の探索
2. 新要素のポインタを挿入位置の次要素に合わせる
3. 挿入位置の前要素のポインタを新要素に合わせる

データの削除は, 次の手順となる.

1. 削除要素の探索
2. 削除要素の前要素を, 削除要素の次要素につなげる

リスト構造に対する処理を, 計算量で評価すると, 挿入/削除位置の探索の計算量は*O*(n)だが, それ以外は*O*(1)である.

## **2. スタック**

**スタック**は「後入れ先出し(LIFO: Last In First Out)」の性質を持つデータ構造である.

スタックへデータを格納する操作を**PUSH**, 取り出す操作を**POP**という. スタックは, `後に格納したデータほど先に取り出される`.

### **スタックの利用法**

#### **1. プログラム呼出し時の戻り番地の管理**

**関数**や**サブルーチン**が処理を終えたとき, それを呼び出した場所に正しく戻る必要があるため, `戻り番地をスタックに格納`してから関数やサブルーチンを呼び出すようにする. 関数やサブルーチンが処理を終えると, スタックから戻り番地をPOPして呼出し元に戻る.

> **サブルーチン**: 主処理から呼び出される処理

#### **2. 逆ポーランド記法の演算**

逆ポーランド記法で記述された演算式は, 1つのスタックだけで計算できるのが特徴である. 具体的には, 演算式を左から順に見ながら, 次の手順を繰り返す. 最終的には, 計算式の解がスタックに格納された状態で終了する.

- 数値であればスタックにPUSHする
- 演算子であればスタックから数値を2つPOPして計算し, 計算結果をスタックにPUSHする

### **スタックの実現方法**

配列でスタックを実現する場合は, 末尾方向に向けてデータをPUSHし, 先頭方向に向けてPOPするようにする. リストでスタックを実現する場合には, `リストの先頭に対してPUSH/POPを行う`.

## **3. キュー**

**キュー**は「先入れ先出し(FIFO: First In First Out)」の性質を持つデータ構造である.

キューへデータを格納する操作を**エンキュー**(enqueue), 取り出す操作を**デキュー**(dequeue)と呼ぶ. 入口と出口が異なるので, `格納した順にデータが取り出される`.

キューは行列など, 順番を持つ要素の管理に向いている. 生成したタスクの管理や, 到達したジョブの管理などはキューの代表例である.

### **キューの実現法**

キューを配列で実現する場合は, エンキューとデキューをともに末尾方向に向けて行う. データの位置は徐々に後方に移動するので, 配列の末尾を超えたら先頭に戻るような工夫が必要である.

リストで実現する場合には, `リストの末尾に対して要素をエンキューし, 先頭要素をデキューする`. 線形リストに末尾ポインタを追加すると追加すると, 末尾への追加を効率化できる.

## **4. 木構造**

**木構造**は親子関係で**階層構造**を表すデータ構造である. 親は複数の子を持つことができるが, 子は一つの親しか持てない.

木の構成要素を**節**(node)と呼ぶ. 特に最上位の節を**根**(root), 子を持たない節を**葉**(leaf)と呼ぶ. 根から数えた階層数を深さ, 最下層の葉から数えた階層数を高さと呼ぶ.

### **二分木**

各節が最大二つの子を持てる木を, **二分木**と呼ぶ.

`高さがnの二分木は, 最大2^(n+1)-1個の節を持つことができる. 節の数がnである二分木の高さはlog_(2)(n+1)-1`となる.

### **2分探索木**

**2分探索木**(binary search tree)とは, 次の2つの条件が全ての節が二分木で, 探索に向いたデータ構造である.

- ある節の左部分木に属する節の値は, その節の値より小さい
- ある節の右部分木に属する節の値は, その節の値より大きい

### **ヒープ**

根から深さの浅い順に, 節を左詰めにした木を**完全二分木**と呼ぶ. 完全二分木の中で, どの親子についても一定の大小関係が成立する木が**ヒープ**(heap)である.

ヒープは`最大値や最小値を効率よく取り出す`ことができるデータ構造である.

### **木の巡回**

木に含まれる全てのデータを処理することもある. このような処理では, 木の全ての節を漏れなく巡回する必要がある. この方法には大きく深さ優先順と幅優先順がある.

- 深さ優先順...子があれば子を優先して巡回する
- 幅優先順...兄弟を優先して巡回する

木の巡回においては「どのタイミングで節を処理するか」によって, 節の訪問順序は大きく変わる. 節の巡回タイミングには以下の3通りがある.

| 処理タイミング | 説明 |
| :-: | :-- |
| 先行順 | 初めて訪問したタイミング |
| 中間順 | 右の子に移るタイミング |
| 後行順 | 親に戻るタイミング |

`式を表す構文木を後行順で巡回すると, 節は逆ポーランド記法に並ぶ`. 先行順で巡回した場合の並びをポーランド記法と呼ぶ. また, 中間順で巡回すると, カッコが欠けてはいるものの, 通常の式の並びとなる.

幅優先順の巡回は, 横方向へのスキャンを上から順番に実施しているイメージとなる.

### **B木**

**B木**は多分木を表すためのデータ構造の1つである. 親はキー値の他に子を指し示すポインタを保持する.

B木やこれを改良した**B+木**は, `データベースのインデックスなどに用いられる`. このとき, 基本的にはキー値の左側のポインタは「キー値よりも小さな値を持つ子」を指し, 右側のポインタは「キー値よりも大きな値を持つ子」を指すよう, データが割り付けられる.

> 2分探索木と同様に, 枝の1つを降りていくような探索が可能である.

## **5. グラフ**

**グラフ**は**頂点**(ノード)と**辺**(エッジ)で結ばれたデータ構造である. 頂点同士には, 木のような関係はなく, また, 辺で結ばれない頂点同士もあり, 辺に重みを付けることができる.

グラフを用いれば, いくつかの地点がどのように結ばれているかなどの`経路情報を表すことができる`.

### **隣接行列**

グラフは, 頂点同士を対応させた**隣接行列**で表すことができる. 辺に重みがない場合は, 経路の有無を1/0で, 距離で重み付けされている場合は, 距離/∞を設定する.
