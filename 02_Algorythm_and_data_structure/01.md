# データ構造

アルゴリズム(処理の手順)とデータ構造(データの配置・管理の方法)が, プログラミングを構成している. ここでは, プログラミングを支える要素のうち, データ構造に焦点を当てる.

## リスト構造

**リスト構造**は要素をチェーンのようにつなぐデータ構造である. 要素はデータを格納する**データ部**と, 次につながる要素(次要素)の位置情報を持つ**ポインタ部**から構成される.

要素の位置は一つ前の要素が保持しているが, リストの開始位置を指すポインタを別途で用意しなければならない. ポインタの内容は, 次要素が格納されたメモリのアドレスなどである. 最終要素のポインタは**NULL**である.

### 要素の追加・削除

リスト構造への要素の追加/削除は, それを行う前後の要素を修正するだけで簡単に実現できる. これは, 挿入場所を確保しなければならない"配列"に比べて, 非常に優れた性質である.

リストへの挿入は, 次の手順で行われる.

1. 挿入位置の探索
2. 新要素のポインタを挿入位置の次要素に合わせる
3. 挿入位置の前要素のポインタを新要素に合わせる

データの削除は, 次の手順となる.

1. 削除要素の探索
2. 削除要素の前要素を, 削除要素の次要素につなげる

リスト構造に対する処理を, 計算量で評価すると, 挿入/削除位置の探索の計算量はO(n)だが, それ以外はO(1)である.

## スタック

**スタック**は「後入れ先出し(LIFO: Last In First Out)」の性質を持つデータ構造である.

スタックへデータを格納する操作を**PUSH**, 取り出す操作を**POP**という. スタックは, 後に格納したデータほど先に取り出される.

### スタックの利用法

#### 1. プログラム呼出し時の戻り番地の管理

**関数**や**サブルーチン**(主処理から呼び出される処理)が処理を終えたとき, それを呼び出した場所に正しく戻る必要がある. そのため, 戻り番地をスタックに格納してから関数やサブルーチンを呼び出すようにする. 関数やサブルーチンが処理を終えると, スタックから戻り番地をPOPして呼出し元に戻る.

#### 2. 逆ポーランド記法の演算

逆ポーランド記法で記述された演算式は, 一つのスタックだけで計算できるのが特徴である. 具体的には, 演算式を左から順に見ながら, 次の手順を繰り返す. s最終的には, 計算式の解がスタックに格納された状態で終了する.

- 数値であればスタックにPUSHする
- 演算子であればスタックから数値を二つPOPして計算し, 計算結果をスタックにPUSHする

### スタックの実現方法

配列でスタックを実現する場合は, 末尾方向に向けてデータをPUSHし, 先頭方向に向けてPOPするようにする. リストでスタックを実現する場合には, リストの先頭に対してPUSH/POPを行う.

## キュー

**キュー**は「先入れ先出し(FIFO: First In First Out)」の性質を持つデータ構造である.

キューへデータを格納する操作を**エンキュー**(enqueue), 取り出す操作を**デキュー**(dequeue)と呼ぶ. 入口と出口が異なるので, 格納した順にデータが取り出される.

キューは行列など, 順番を持つ要素の管理に向いている. 生成したタスクの管理や, 到達したジョブの管理などはキューの代表例である.

### キューの実現法

キューを配列で実現する場合は, エンキューとデキューをともに末尾方向に向けて行う. データの位置は徐々に後方に移動するので, 配列の末尾を超えたら先頭に戻るような工夫が必要である.

リストで実現する場合には, リストの末尾に対して要素をエンキューし, 先頭要素をデキューする. 線形リストに末尾ポインタを追加すると追加すると, 末尾への追加を効率化できる.

## 木構造

**木構造**は親子関係で**階層構造**を表すデータ構造である. 親は複数の子を持つことができるが, 子は一つの親しか持てない.

木の構成要素を**節**(node)と呼ぶ. 特に最上位の節を**根**(root), 子を持たない節を**葉**(leaf)と呼ぶ. 根から数えた階層数を深さ, 最下層の葉から数えた階層数を高さと呼ぶ.

### 二分木

各節が最大二つの子を持てる木を, **二分木**と呼ぶ.

高さがnの二分木は, 最大2^(n+1)-1個の節を持つことができる. 節の数がnである二分木の高さはlog_(2)(n+1)-1となる.

### 2分探索木

**2分探索木**(binary search tree)とは, 次の二つの条件が全ての節が二分木で, 探索に向いたデータ構造である.

- ある節の左部分木に属する節の値は, その節の値より小さい
- ある節の右部分木に属する節の値は, その節の値より大きい

### ヒープ

根から深さの浅い順に, 節を左詰めにした木を**完全二分木**と呼ぶ. 完全二分木の中で, どの親子についても一定の大小関係が成立する木が**ヒープ**(heap)である.

ヒープは最大値や最小値を効率よく取り出すことができるデータ構造である.

### 木の巡回

木に含まれる全てのデータを処理することもある. このような処理では, 木の全ての節を漏れなく巡回する必要がある. この方法には大きく深さ優先順と幅優先順がある.

- 深さ優先順...子があれば子を優先して巡回する
- 幅優先順...兄弟を優先して巡回する
